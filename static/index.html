<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>HomePod Control</title>
  <style>
    :root {
      --bg: #050712;
      --bg-2: #090d1f;
      --card: rgba(11, 15, 31, 0.78);
      --card-2: rgba(7, 10, 24, 0.9);
      --ink: #e5e9f5;
      --muted: #9aa4c2;
      --line: rgba(255, 255, 255, 0.14);
      --accent: #15f6ff;
      --accent-2: #ff3dff;
      --accent-3: #7cff6b;
      --accent-4: #ffe86b;
      --danger: #ff5e7e;
      --ok: #76ffce;
      --radius: 18px;
      --shadow: 0 18px 50px rgba(0, 0, 0, 0.55);
      --shadow-soft: 0 12px 36px rgba(0, 0, 0, 0.35);
      --font: "Rajdhani", "Orbitron", "IBM Plex Sans", "Segoe UI", sans-serif;
      --mono: "IBM Plex Mono", "JetBrains Mono", "Consolas", monospace;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: var(--font);
      color: var(--ink);
      min-height: 100vh;
      background:
        radial-gradient(1200px 860px at 16% 6%, rgba(21, 246, 255, 0.14), transparent 60%),
        radial-gradient(1100px 880px at 88% 18%, rgba(255, 61, 255, 0.14), transparent 58%),
        radial-gradient(940px 780px at 52% 100%, rgba(124, 255, 107, 0.08), transparent 58%),
        linear-gradient(180deg, var(--bg-2) 0%, var(--bg) 70%);
      animation: scene 620ms ease-out;
      overflow-x: hidden;
    }

    body::before,
    body::after {
      content: "";
      position: fixed;
      inset: 0;
      pointer-events: none;
      z-index: -1;
    }

    body::before {
      background:
        linear-gradient(rgba(21, 246, 255, 0.07) 1px, transparent 1px),
        linear-gradient(90deg, rgba(21, 246, 255, 0.06) 1px, transparent 1px);
      background-size: 52px 52px;
      mask-image: radial-gradient(circle at 50% 35%, black, transparent 80%);
      opacity: 0.45;
    }

    body::after {
      background: linear-gradient(
        180deg,
        rgba(255, 255, 255, 0.03) 0%,
        rgba(255, 255, 255, 0) 28%,
        rgba(255, 255, 255, 0) 72%,
        rgba(255, 255, 255, 0.04) 100%
      );
      opacity: 0.5;
    }

    @keyframes scene {
      from {
        opacity: 0;
        transform: translateY(10px) scale(0.995);
      }
      to {
        opacity: 1;
        transform: translateY(0) scale(1);
      }
    }

    .wrap {
      max-width: 1160px;
      margin: 0 auto;
      padding: 26px 18px 38px;
    }

    .head {
      margin-bottom: 22px;
    }

    .brand-panel {
      position: relative;
      border-radius: calc(var(--radius) + 4px);
      border: 1px solid rgba(255, 255, 255, 0.18);
      padding: 16px 16px 14px;
      background: linear-gradient(180deg, rgba(10, 14, 30, 0.9), rgba(6, 10, 24, 0.84));
      box-shadow: var(--shadow);
      overflow: hidden;
      transform-style: preserve-3d;
    }

    .brand-panel::before {
      content: "";
      position: absolute;
      inset: -2px;
      background: conic-gradient(
        from 180deg,
        rgba(21, 246, 255, 0.52),
        rgba(255, 61, 255, 0.48),
        rgba(124, 255, 107, 0.42),
        rgba(255, 232, 107, 0.4),
        rgba(21, 246, 255, 0.52)
      );
      filter: blur(16px);
      opacity: 0.6;
      z-index: -1;
    }

    .brand-panel::after {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(
        180deg,
        rgba(255, 255, 255, 0.16),
        rgba(255, 255, 255, 0.04) 22%,
        rgba(0, 0, 0, 0.22) 100%
      );
      mix-blend-mode: soft-light;
      pointer-events: none;
    }

    .brand-line {
      margin: 0 0 5px;
      font-size: 0.78rem;
      letter-spacing: 0.24em;
      text-transform: uppercase;
      color: var(--accent);
      text-shadow: 0 0 14px rgba(21, 246, 255, 0.45);
    }

    .title {
      margin: 0;
      font-size: clamp(1.7rem, 3.8vw, 2.35rem);
      letter-spacing: 0.08em;
      font-weight: 700;
      text-transform: uppercase;
      background: linear-gradient(
        90deg,
        var(--accent),
        #6ee8ff 22%,
        var(--accent-2) 55%,
        var(--accent-3) 82%,
        var(--accent-4)
      );
      -webkit-background-clip: text;
      background-clip: text;
      color: transparent;
      text-shadow:
        0 0 12px rgba(21, 246, 255, 0.23),
        0 0 18px rgba(255, 61, 255, 0.2);
    }

    .sub {
      margin: 6px 0 10px;
      color: var(--muted);
      font-size: 0.98rem;
      max-width: 62ch;
    }

    .head-pills {
      display: flex;
      flex-wrap: wrap;
      gap: 7px;
    }

    .head-pill {
      border-radius: 999px;
      padding: 5px 10px;
      font-size: 0.75rem;
      letter-spacing: 0.05em;
      border: 1px solid rgba(255, 255, 255, 0.2);
      background: rgba(255, 255, 255, 0.03);
      box-shadow: inset 0 0 16px rgba(21, 246, 255, 0.1);
    }

    .overview {
      margin-top: 12px;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 10px;
    }

    .overview-item {
      border-radius: 12px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      background: rgba(2, 9, 23, 0.66);
      padding: 7px 9px 8px;
      box-shadow: inset 0 0 18px rgba(21, 246, 255, 0.08);
    }

    .overview-label {
      display: block;
      font-size: 0.7rem;
      letter-spacing: 0.11em;
      text-transform: uppercase;
      color: #a7b4d8;
      margin-bottom: 2px;
    }

    .overview-value {
      display: block;
      font-size: 0.96rem;
      letter-spacing: 0.04em;
      color: #ecf4ff;
      font-weight: 700;
    }

    .dashboard {
      display: grid;
      grid-template-columns: minmax(0, 1.65fr) minmax(280px, 1fr);
      gap: 16px;
      align-items: start;
    }

    .stack {
      display: grid;
      gap: 16px;
    }

    .card {
      position: relative;
      background: linear-gradient(180deg, var(--card), var(--card-2));
      border: 1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow-soft);
      padding: 15px;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      transform-style: preserve-3d;
      transition: transform 220ms ease, border-color 220ms ease, box-shadow 220ms ease;
      overflow: hidden;
    }

    .card::before {
      content: "";
      position: absolute;
      inset: -50% -10% auto;
      height: 60%;
      background: linear-gradient(
        110deg,
        rgba(21, 246, 255, 0.22),
        rgba(255, 61, 255, 0.18),
        rgba(124, 255, 107, 0.15),
        rgba(255, 255, 255, 0)
      );
      transform: rotate(6deg);
      opacity: 0.8;
      pointer-events: none;
    }

    .card:hover {
      transform: none;
      border-color: rgba(21, 246, 255, 0.45);
      box-shadow:
        0 22px 52px rgba(0, 0, 0, 0.55),
        0 0 22px rgba(21, 246, 255, 0.2);
    }

    h2 {
      margin: 0 0 10px;
      font-size: 0.98rem;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      color: #cde2ff;
      text-shadow: 0 0 10px rgba(21, 246, 255, 0.32);
    }

    .card-sub {
      margin: -2px 0 10px;
      color: #9fb0d7;
      font-size: 0.9rem;
      letter-spacing: 0.02em;
    }

    label {
      display: block;
      font-size: 0.8rem;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      margin-bottom: 4px;
      color: #a7b4d8;
    }

    input[type="text"] {
      width: 100%;
      padding: 10px 11px;
      border-radius: 10px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      background: rgba(1, 8, 24, 0.6);
      color: var(--ink);
      box-shadow: inset 0 0 0 1px rgba(21, 246, 255, 0.05);
      outline: none;
      transition: border-color 160ms ease, box-shadow 160ms ease, transform 160ms ease;
      font-family: var(--mono);
    }

    input[type="text"]:focus {
      border-color: rgba(21, 246, 255, 0.76);
      box-shadow:
        inset 0 0 0 1px rgba(21, 246, 255, 0.26),
        0 0 0 3px rgba(21, 246, 255, 0.12),
        0 0 18px rgba(21, 246, 255, 0.18);
      transform: translateY(-1px);
    }

    input[type="range"] {
      width: 100%;
      accent-color: var(--accent);
      filter: drop-shadow(0 0 8px rgba(21, 246, 255, 0.42));
    }

    .control-group + .control-group {
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid rgba(255, 255, 255, 0.12);
    }

    .control-title {
      font-size: 0.76rem;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: #a5b6dd;
      margin: 0 0 4px;
    }

    .service-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 8px;
      margin-top: 8px;
    }

    .field-grid {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 8px;
      margin-top: 8px;
    }

    .service-btn {
      min-height: 44px;
    }

    .voice-status {
      margin-top: 10px;
      min-height: 48px;
      font-size: 0.82rem;
      line-height: 1.35;
    }

    .voice-debug {
      margin-top: 8px;
      min-height: 64px;
      font-size: 0.78rem;
      line-height: 1.3;
      white-space: pre-line;
      color: #9cb0d8;
    }

    .voice-live {
      color: var(--accent-4);
      text-shadow: 0 0 10px rgba(255, 232, 107, 0.3);
    }

    .voice-idle {
      color: #a7b5d8;
    }

    .mic-active {
      border-color: rgba(255, 232, 107, 0.85);
      box-shadow:
        inset 0 1px 0 rgba(255, 255, 255, 0.28),
        0 14px 24px rgba(0, 0, 0, 0.45),
        0 0 22px rgba(255, 232, 107, 0.4);
      filter: saturate(1.15);
    }

    .row {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-top: 8px;
      flex-wrap: wrap;
    }

    .btn-row {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(132px, 1fr));
      gap: 8px;
      align-items: stretch;
    }

    .queue-row {
      grid-template-columns: repeat(auto-fit, minmax(146px, 1fr));
    }

    .queue-row .queue-badge {
      grid-column: 1 / -1;
      justify-self: start;
    }

    button {
      position: relative;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
      isolation: isolate;
      border: 1px solid rgba(255, 255, 255, 0.22);
      border-radius: 11px;
      padding: 10px 13px;
      min-height: 44px;
      cursor: pointer;
      font-weight: 700;
      font-size: 0.77rem;
      letter-spacing: 0.08em;
      line-height: 1;
      text-transform: uppercase;
      color: #f5f8ff;
      background:
        radial-gradient(120% 140% at 20% 18%, rgba(255, 255, 255, 0.18), transparent 46%),
        linear-gradient(140deg, rgba(57, 78, 118, 0.84), rgba(15, 23, 41, 0.98));
      box-shadow:
        inset 0 1px 0 rgba(255, 255, 255, 0.22),
        inset 0 -8px 14px rgba(0, 0, 0, 0.28),
        0 10px 20px rgba(0, 0, 0, 0.34),
        0 0 18px rgba(21, 246, 255, 0.2);
      transition: transform 140ms ease, box-shadow 160ms ease, border-color 160ms ease, filter 160ms ease, background 180ms ease;
    }

    button::before {
      content: "";
      position: absolute;
      inset: 0;
      background: linear-gradient(
        180deg,
        rgba(255, 255, 255, 0.25),
        rgba(255, 255, 255, 0.05) 42%,
        rgba(0, 0, 0, 0.18) 100%
      );
      pointer-events: none;
      z-index: -1;
    }

    button::after {
      content: "";
      position: absolute;
      top: -120%;
      left: -40%;
      width: 50%;
      height: 320%;
      background: linear-gradient(
        120deg,
        rgba(255, 255, 255, 0) 0%,
        rgba(255, 255, 255, 0.25) 48%,
        rgba(255, 255, 255, 0) 100%
      );
      transform: rotate(16deg);
      transition: left 260ms ease;
      pointer-events: none;
    }

    button:hover {
      border-color: rgba(21, 246, 255, 0.8);
      box-shadow:
        inset 0 1px 0 rgba(255, 255, 255, 0.28),
        inset 0 -8px 14px rgba(0, 0, 0, 0.34),
        0 14px 22px rgba(0, 0, 0, 0.4),
        0 0 20px rgba(21, 246, 255, 0.34);
      filter: saturate(1.08);
    }

    button:hover::after {
      left: 115%;
    }

    button:focus-visible {
      outline: none;
      border-color: rgba(21, 246, 255, 0.95);
      box-shadow:
        inset 0 1px 0 rgba(255, 255, 255, 0.26),
        0 0 0 3px rgba(21, 246, 255, 0.2),
        0 0 22px rgba(21, 246, 255, 0.4);
    }

    button:disabled {
      opacity: 0.58;
      cursor: not-allowed;
      filter: grayscale(0.35);
      transform: none;
    }

    .btn-primary {
      background:
        radial-gradient(120% 140% at 20% 18%, rgba(255, 255, 255, 0.24), transparent 46%),
        linear-gradient(140deg, rgba(21, 246, 255, 0.58), rgba(20, 38, 76, 0.98));
    }

    .btn-secondary,
    .alt {
      background:
        radial-gradient(120% 140% at 20% 18%, rgba(255, 255, 255, 0.22), transparent 46%),
        linear-gradient(140deg, rgba(124, 255, 107, 0.58), rgba(20, 60, 42, 0.98));
    }

    .btn-tertiary,
    .warm {
      background:
        radial-gradient(120% 140% at 20% 18%, rgba(255, 255, 255, 0.22), transparent 46%),
        linear-gradient(140deg, rgba(255, 61, 255, 0.56), rgba(74, 12, 88, 0.98));
    }

    .btn-danger,
    .danger {
      background:
        radial-gradient(120% 140% at 20% 18%, rgba(255, 255, 255, 0.2), transparent 46%),
        linear-gradient(140deg, rgba(255, 94, 126, 0.64), rgba(104, 16, 44, 0.98));
    }

    .pill {
      display: inline-block;
      border: 1px solid rgba(255, 255, 255, 0.25);
      padding: 5px 9px;
      border-radius: 999px;
      font-size: 0.85rem;
      background: rgba(255, 255, 255, 0.05);
      color: #dbe6ff;
      box-shadow: inset 0 0 14px rgba(21, 246, 255, 0.12);
    }

    .status {
      margin-top: 8px;
      background: rgba(5, 10, 24, 0.72);
      border: 1px dashed rgba(21, 246, 255, 0.38);
      border-radius: 10px;
      padding: 9px;
      font-size: 0.9rem;
      line-height: 1.4;
      min-height: 66px;
      white-space: pre-wrap;
      word-break: break-word;
      color: #dce8ff;
      box-shadow: inset 0 0 22px rgba(21, 246, 255, 0.06);
    }

    .status-compact {
      min-height: 48px;
      font-size: 0.8rem;
      line-height: 1.35;
    }

    .list {
      margin-top: 10px;
      display: grid;
      gap: 7px;
      max-height: 220px;
      overflow: auto;
      padding-right: 2px;
    }

    .list-item {
      border: 1px solid rgba(255, 255, 255, 0.18);
      border-radius: 10px;
      background: rgba(2, 8, 20, 0.65);
      padding: 8px;
      box-shadow: inset 0 0 12px rgba(21, 246, 255, 0.08);
    }

    .list-name {
      display: block;
      font-size: 0.84rem;
      color: #e9f2ff;
      line-height: 1.3;
      word-break: break-word;
    }

    .list-meta {
      display: block;
      margin-top: 3px;
      font-size: 0.72rem;
      color: #9db0da;
      letter-spacing: 0.03em;
    }

    .list-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      margin-top: 7px;
    }

    .mini-btn {
      min-height: 30px;
      padding: 6px 8px;
      font-size: 0.68rem;
      letter-spacing: 0.06em;
    }

    .queue-badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      border: 1px solid rgba(255, 255, 255, 0.24);
      border-radius: 999px;
      padding: 5px 9px;
      font-size: 0.78rem;
      background: rgba(255, 255, 255, 0.05);
      color: #dce8ff;
    }

    .output {
      min-height: 220px;
      font-family: var(--mono);
      font-size: 0.84rem;
      background: rgba(2, 8, 20, 0.84);
      border-color: rgba(255, 61, 255, 0.33);
    }

    .ok {
      color: var(--ok);
      font-weight: 700;
      text-shadow: 0 0 12px rgba(118, 255, 206, 0.3);
    }

    .bad {
      color: var(--danger);
      font-weight: 700;
      text-shadow: 0 0 12px rgba(255, 94, 126, 0.35);
    }

    .hidden {
      display: none !important;
    }

    .remote-card .card-sub {
      margin-bottom: 14px;
    }

    .remote-shell {
      position: relative;
      border-radius: 22px;
      border: 1px solid rgba(255, 255, 255, 0.2);
      background:
        radial-gradient(120% 140% at 18% 10%, rgba(124, 255, 107, 0.1), transparent 55%),
        radial-gradient(130% 140% at 90% 10%, rgba(255, 61, 255, 0.14), transparent 56%),
        linear-gradient(180deg, rgba(12, 18, 42, 0.95), rgba(8, 13, 30, 0.95));
      box-shadow:
        inset 0 1px 0 rgba(255, 255, 255, 0.14),
        0 18px 35px rgba(0, 0, 0, 0.45);
      padding: 12px;
      overflow: hidden;
    }

    .remote-shell::after {
      content: "";
      position: absolute;
      left: 8px;
      right: 8px;
      top: 62px;
      bottom: 8px;
      border-radius: 18px;
      background: linear-gradient(180deg, rgba(4, 8, 18, 0.94), rgba(1, 3, 10, 0.98));
      border: 1px solid rgba(255, 255, 255, 0.12);
      box-shadow:
        inset 0 1px 0 rgba(255, 255, 255, 0.1),
        inset 0 -20px 30px rgba(0, 0, 0, 0.45),
        0 12px 24px rgba(0, 0, 0, 0.34);
      z-index: 0;
      pointer-events: none;
    }

    .remote-top {
      position: relative;
      z-index: 1;
      display: grid;
      grid-template-columns: minmax(0, 1fr) minmax(0, 1fr) auto;
      gap: 8px;
      align-items: center;
      margin-bottom: 12px;
    }

    .device-tab {
      min-height: 42px;
      border-radius: 999px;
      text-transform: none;
      letter-spacing: 0.03em;
      font-size: 0.8rem;
      background:
        radial-gradient(120% 140% at 20% 18%, rgba(255, 255, 255, 0.16), transparent 46%),
        linear-gradient(140deg, rgba(51, 67, 104, 0.9), rgba(15, 23, 41, 0.95));
      color: #d7e8ff;
      border-color: rgba(255, 255, 255, 0.22);
    }

    .device-tab.is-active {
      border-color: rgba(118, 252, 255, 0.95);
      color: #041120;
      background:
        radial-gradient(130% 140% at 20% 18%, rgba(255, 255, 255, 0.45), transparent 48%),
        linear-gradient(140deg, rgba(127, 249, 255, 0.95), rgba(111, 193, 255, 0.95));
      box-shadow:
        inset 0 1px 0 rgba(255, 255, 255, 0.5),
        0 0 18px rgba(127, 249, 255, 0.34);
    }

    .power-dot {
      min-width: 84px;
      min-height: 42px;
      border-radius: 999px;
      text-transform: none;
      letter-spacing: 0.04em;
      font-size: 0.8rem;
      padding-inline: 12px;
    }

    .remote-body {
      position: relative;
      z-index: 1;
      display: grid;
      gap: 12px;
    }

    .remote-pad {
      margin: 0 auto;
      width: min(340px, 100%);
      aspect-ratio: 1 / 1;
      border-radius: 50%;
      position: relative;
      background:
        radial-gradient(circle at 35% 20%, rgba(255, 255, 255, 0.22), transparent 45%),
        linear-gradient(160deg, rgba(43, 57, 92, 0.9), rgba(9, 16, 35, 0.96));
      border: 1px solid rgba(255, 255, 255, 0.24);
      box-shadow:
        inset 0 -10px 22px rgba(0, 0, 0, 0.5),
        inset 0 8px 16px rgba(255, 255, 255, 0.08),
        0 18px 28px rgba(0, 0, 0, 0.42);
    }

    .pad-btn {
      position: absolute;
      width: 82px;
      height: 82px;
      border-radius: 50%;
      min-height: 82px;
      text-transform: none;
      letter-spacing: 0;
      font-size: 1.55rem;
      font-weight: 700;
      padding: 0;
      color: #f3f8ff;
      background:
        radial-gradient(120% 120% at 20% 16%, rgba(255, 255, 255, 0.2), transparent 46%),
        linear-gradient(150deg, rgba(80, 98, 139, 0.82), rgba(20, 31, 55, 0.96));
      border-color: rgba(255, 255, 255, 0.26);
    }

    .pad-btn-up {
      top: 12px;
      left: 50%;
      transform: translateX(-50%);
    }

    .pad-btn-down {
      bottom: 12px;
      left: 50%;
      transform: translateX(-50%);
    }

    .pad-btn-left {
      left: 12px;
      top: 50%;
      transform: translateY(-50%);
    }

    .pad-btn-right {
      right: 12px;
      top: 50%;
      transform: translateY(-50%);
    }

    .pad-btn-center {
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 108px;
      height: 108px;
      min-height: 108px;
      font-size: 0.9rem;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      border-color: rgba(124, 255, 107, 0.6);
      background:
        radial-gradient(130% 130% at 30% 22%, rgba(255, 255, 255, 0.3), transparent 46%),
        linear-gradient(150deg, rgba(124, 255, 107, 0.7), rgba(20, 74, 37, 0.95));
      color: #0a1d09;
      box-shadow:
        inset 0 1px 0 rgba(255, 255, 255, 0.48),
        0 12px 20px rgba(0, 0, 0, 0.35),
        0 0 18px rgba(124, 255, 107, 0.35);
    }

    .remote-media-row {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 8px;
    }

    .remote-media-row button {
      min-height: 44px;
      border-radius: 14px;
      text-transform: none;
      letter-spacing: 0.03em;
      font-size: 0.82rem;
    }

    .remote-volume-row {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 8px;
    }

    .remote-tv-row {
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 8px;
    }

    .remote-tv-row-3 {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 8px;
    }

    .remote-actions {
      display: grid;
      grid-template-columns: repeat(4, minmax(0, 1fr));
      gap: 8px;
    }

    .app-tile {
      min-height: 72px;
      border-radius: 16px;
      text-transform: none;
      letter-spacing: 0.02em;
      font-size: 0.8rem;
      font-weight: 700;
      padding: 8px;
    }

    .app-netflix {
      background: linear-gradient(145deg, rgba(229, 9, 20, 0.95), rgba(114, 7, 13, 0.95));
      border-color: rgba(255, 140, 149, 0.72);
    }

    .app-amazon {
      background: linear-gradient(145deg, rgba(35, 122, 238, 0.95), rgba(20, 71, 140, 0.95));
      border-color: rgba(149, 201, 255, 0.62);
    }

    .app-joyn {
      background: linear-gradient(145deg, rgba(255, 56, 194, 0.92), rgba(150, 30, 126, 0.95));
      border-color: rgba(255, 158, 227, 0.66);
    }

    .app-spotify {
      background: linear-gradient(145deg, rgba(34, 197, 94, 0.95), rgba(21, 113, 60, 0.95));
      border-color: rgba(148, 255, 192, 0.62);
    }

    .app-voice {
      background: linear-gradient(145deg, rgba(154, 87, 255, 0.95), rgba(83, 44, 147, 0.95));
      border-color: rgba(203, 169, 255, 0.66);
    }

    @media (max-width: 680px) {
      .wrap {
        padding: 16px 12px 24px;
      }

      .brand-panel {
        padding: 14px 12px 12px;
      }

      .title {
        font-size: clamp(1.45rem, 7.4vw, 1.95rem);
      }

      .overview {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }

      .service-grid {
        grid-template-columns: 1fr;
      }

      .field-grid {
        grid-template-columns: 1fr;
      }

      .dashboard {
        grid-template-columns: 1fr;
      }

      .row {
        gap: 6px;
      }

      .btn-row {
        grid-template-columns: 1fr;
      }

      .remote-top {
        grid-template-columns: 1fr 1fr;
      }

      .power-dot {
        grid-column: 1 / -1;
      }

      .remote-actions {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }

      .remote-media-row {
        grid-template-columns: repeat(2, minmax(0, 1fr));
      }
    }
  </style>
</head>
<body>
  <main class="wrap">
    <header class="head">
      <div class="brand-panel">
        <div class="brand-line">APPLE TV + HOMEPOD // REMOTE DESIGN</div>
        <h1 class="title">Remote Control Studio</h1>
        <p class="sub">Design aus deiner <code>.make</code>-Datei uebernommen: Device-Switch, D-Pad, Quick Actions und volle API-Anbindung.</p>
        <div class="head-pills">
          <span class="head-pill">AirPlay</span>
          <span class="head-pill">RAOP</span>
          <span class="head-pill">Low Latency</span>
          <span class="head-pill" id="headNode">Node: -</span>
        </div>
        <div class="overview">
          <div class="overview-item">
            <span class="overview-label">Geraet</span>
            <span id="overviewNode" class="overview-value">-</span>
          </div>
          <div class="overview-item">
            <span class="overview-label">IP</span>
            <span id="overviewIp" class="overview-value">-</span>
          </div>
          <div class="overview-item">
            <span class="overview-label">Lautstaerke</span>
            <span id="overviewVolume" class="overview-value">-</span>
          </div>
          <div class="overview-item">
            <span class="overview-label">Stream</span>
            <span id="overviewStream" class="overview-value">-</span>
          </div>
          <div class="overview-item">
            <span class="overview-label">State</span>
            <span id="overviewState" class="overview-value">-</span>
          </div>
        </div>
      </div>
    </header>

    <section class="dashboard">
      <div class="stack main-stack">
        <article class="card">
          <h2>Playback</h2>
          <p class="card-sub">Quelle setzen, Musik/Video hinzufuegen, Stream starten/stoppen und Zustand abrufen.</p>
          <label for="path">Datei oder URL</label>
          <input id="path" type="text" placeholder="/voller/pfad/zur/datei.mp3">
          <input
            id="mediaFileInput"
            type="file"
            accept="audio/*,video/*,.mp3,.m4a,.aac,.flac,.wav,.ogg,.opus,.mp4,.m4v,.mov,.mkv,.webm,.avi"
            style="display:none;"
          >
          <div class="row btn-row">
            <button id="addMedia" class="btn-tertiary">Medien hinzufuegen</button>
            <button id="queueAdd" class="btn-secondary">Zur Playlist</button>
            <button id="play" class="btn-primary">Play</button>
            <button id="stop" class="btn-danger">Stop</button>
            <button id="refreshPlaying" class="btn-secondary">Status</button>
          </div>
          <div class="row">
            <span id="mediaHint" class="pill">Keine Datei ausgewaehlt</span>
          </div>
          <div class="control-group">
            <p class="control-title">Playlist</p>
            <div class="row btn-row queue-row">
              <button id="queueStart" class="btn-primary">Playlist Start</button>
              <button id="queueNext" class="btn-tertiary">Naechster</button>
              <button id="queueClear" class="btn-danger">Playlist leeren</button>
              <span id="queueBadge" class="queue-badge">Queue: -</span>
            </div>
            <div id="queueList" class="list">
              <div class="list-item"><span class="list-meta">Queue leer</span></div>
            </div>
          </div>
          <div class="control-group">
            <p class="control-title">Zuletzt hinzugefuegte Medien</p>
            <div id="historyList" class="list">
              <div class="list-item"><span class="list-meta">Noch keine Uploads</span></div>
            </div>
          </div>
          <div class="row" style="margin-top:10px;">
            <span class="pill">Stream: <strong id="streamFlag">-</strong></span>
          </div>
        </article>

        <article class="card remote-card">
          <h2>Remote</h2>
          <p class="card-sub">Apple TV / HomePod Layout aus dem Design-Entwurf mit direkter Steuerung.</p>
          <div class="remote-shell">
            <div class="remote-top">
              <button id="deviceAppleTV" class="device-tab is-active">Apple TV</button>
              <button id="deviceHomePod" class="device-tab">HomePod</button>
              <button id="rStop" class="power-dot btn-danger">Stop</button>
            </div>

            <div class="remote-body">
              <div class="remote-pad tv-only">
                <button id="rUp" class="pad-btn pad-btn-up" title="Up">▲</button>
                <button id="rDown" class="pad-btn pad-btn-down" title="Down">▼</button>
                <button id="rLeft" class="pad-btn pad-btn-left" title="Left">◀</button>
                <button id="rRight" class="pad-btn pad-btn-right" title="Right">▶</button>
                <button id="rPlayPause" class="pad-btn pad-btn-center" title="Bestaetigen">OK</button>
              </div>

              <div class="remote-media-row">
                <button id="rPrev" class="btn-secondary">Prev</button>
                <button id="rPlay" class="btn-tertiary">Play</button>
                <button id="rPause" class="btn-tertiary">Pause</button>
                <button id="rNext" class="btn-secondary">Next</button>
              </div>

              <div class="remote-media-row">
                <button id="rSkipBack" class="btn-secondary">Skip -</button>
                <button id="rSkipFwd" class="btn-secondary">Skip +</button>
                <button id="rVolDown" class="btn-tertiary">Vol -</button>
                <button id="rVolUp" class="btn-tertiary">Vol +</button>
              </div>

              <div class="remote-tv-row-3 tv-only">
                <button id="rBackExit" class="btn-secondary">Zurueck</button>
                <button id="rMenu" class="btn-secondary">Menu</button>
                <button id="rHome" class="btn-secondary">Home</button>
              </div>
              <div class="remote-tv-row tv-only">
                <button id="rTopMenu" class="btn-secondary">Top Menu</button>
                <button id="rControlCenter" class="btn-secondary">Control Center</button>
              </div>

              <div class="remote-actions">
                <button id="svcNetflix" class="app-tile app-netflix">Netflix</button>
                <button id="svcAmazon" class="app-tile app-amazon">Amazon</button>
                <button id="svcJoyn" class="app-tile app-joyn">Joyn</button>
                <button id="svcSpotify" class="app-tile app-spotify">Spotify</button>
                <button id="voiceToggle" class="app-tile app-voice">Voice Start</button>
                <button id="voiceHelp" class="app-tile btn-secondary">Befehle</button>
              </div>

              <div id="voiceStatus" class="status voice-status voice-idle">Sprachsteuerung: inaktiv</div>
              <div id="voiceIntentDebug" class="status voice-debug">Voice Diagnose: -</div>
              <div class="pill">Tastatur: Pfeile = Navigation, Enter = OK</div>
            </div>
          </div>
        </article>

        <article class="card">
          <h2>Rueckmeldung</h2>
          <p class="card-sub">Live-Meldungen und Rohausgabe der Kommandos.</p>
          <div id="status" class="status">Bereit.</div>
          <div id="output" class="status output">(keine Ausgabe)</div>
        </article>
      </div>

      <aside class="stack side-stack">
        <article class="card">
          <h2>Geraet</h2>
          <p class="card-sub">Verbindungsziel fuer alle Kommandos.</p>
          <label for="ip">IP</label>
          <input id="ip" type="text" placeholder="HomePod IP-Adresse">
          <label for="name" style="margin-top:8px;">Name</label>
          <input id="name" type="text" placeholder="HomePod">
          <div class="row btn-row">
            <button id="saveConfig" class="btn-primary">Speichern</button>
            <button id="reloadConfig" class="btn-secondary">Neu laden</button>
          </div>
          <div class="control-group">
            <p class="control-title">Verbindung</p>
            <div class="row btn-row">
              <button id="connectHomepod" class="btn-primary">HomePod verbinden</button>
              <button id="connectAppleTV" class="btn-secondary">Apple TV verbinden</button>
              <button id="connectAll" class="btn-tertiary">Alle verbinden</button>
            </div>
            <div id="connectStatus" class="status status-compact">Verbindung: nicht geprueft</div>
          </div>
        </article>

        <article class="card">
          <h2>Lautstaerke</h2>
          <p class="card-sub">Praezise Regelung und schnelle Schritte.</p>
          <span class="pill">Aktuell: <strong id="volumeLabel">-</strong>%</span>
          <div class="row" style="margin-top:10px;">
            <input id="volumeSlider" type="range" min="0" max="100" step="1" value="45">
          </div>
          <div class="row btn-row">
            <button id="setVolume" class="btn-primary">Setzen</button>
            <button id="volDown" class="btn-tertiary">-5</button>
            <button id="volUp" class="btn-tertiary">+5</button>
            <button id="refreshVolume" class="btn-secondary">Abfragen</button>
          </div>
        </article>

        <article class="card">
          <h2>ATV Tools</h2>
          <p class="card-sub">Diagnose und freie Befehle.</p>
          <div class="row btn-row">
            <button id="showFeatures" class="btn-secondary">Features</button>
            <button id="showDeviceInfo" class="btn-secondary">Device Info</button>
            <button id="scanDevices" class="btn-tertiary">Scan</button>
          </div>
          <label for="rawCommand" style="margin-top:10px;">Direkter atvremote command</label>
          <input id="rawCommand" type="text" placeholder='z.B. "playing" oder "volume_up"'>
          <div class="row btn-row">
            <button id="runRawCommand" class="btn-primary">Ausfuehren</button>
          </div>
        </article>

        <article class="card">
          <h2>Apple TV Ziel</h2>
          <p class="card-sub">Zielgeraet fuer Service-Launch, Remote und Bildschirmstream.</p>
          <label for="tvIp">Apple TV IP</label>
          <input id="tvIp" type="text" placeholder="Apple TV IP-Adresse">
          <label for="tvName" style="margin-top:8px;">Apple TV Name</label>
          <input id="tvName" type="text" placeholder="Apple TV">
          <div class="row btn-row">
            <button id="saveTvConfig" class="btn-primary">TV speichern</button>
            <button id="reloadTvConfig" class="btn-secondary">TV laden</button>
          </div>
          <div class="row">
            <span class="pill">Services und Voice sind direkt im Remote-Bereich</span>
          </div>
        </article>

        <article class="card">
          <h2>Bildschirm Stream</h2>
          <p class="card-sub">Laptop-Bildschirm live auf Apple TV via <code>play_url</code>.</p>
          <label for="screenDisplay">Display (X11)</label>
          <input id="screenDisplay" type="text" placeholder=":0.0">
          <div class="field-grid">
            <div>
              <label for="screenSize">Aufloesung</label>
              <input id="screenSize" type="text" placeholder="1280x720">
            </div>
            <div>
              <label for="screenFps">FPS</label>
              <input id="screenFps" type="text" placeholder="22">
            </div>
          </div>
          <div class="row btn-row">
            <button id="screenStart" class="btn-primary">Screen Start</button>
            <button id="screenStop" class="btn-danger">Screen Stop</button>
            <button id="screenRefresh" class="btn-secondary">Screen Status</button>
          </div>
          <div class="row btn-row">
            <button id="systemMirrorOpen" class="btn-tertiary">System Mirror</button>
          </div>
          <div id="screenStatus" class="status status-compact">Screen-Stream: inaktiv</div>
        </article>
      </aside>
    </section>
  </main>

  <script>
    const $ = (id) => document.getElementById(id);
    const statusEl = $("status");
    const outputEl = $("output");
    const headNodeEl = $("headNode");
    const overviewNodeEl = $("overviewNode");
    const overviewIpEl = $("overviewIp");
    const overviewVolumeEl = $("overviewVolume");
    const overviewStreamEl = $("overviewStream");
    const overviewStateEl = $("overviewState");
    const connectStatusEl = $("connectStatus");
    const mediaHintEl = $("mediaHint");
    const queueBadgeEl = $("queueBadge");
    const queueListEl = $("queueList");
    const historyListEl = $("historyList");
    const mediaFileInputEl = $("mediaFileInput");
    const voiceStatusEl = $("voiceStatus");
    const voiceIntentDebugEl = $("voiceIntentDebug");
    const voiceToggleBtn = $("voiceToggle");
    const deviceAppleTVBtn = $("deviceAppleTV");
    const deviceHomePodBtn = $("deviceHomePod");
    const screenStatusEl = $("screenStatus");
    const SpeechRecognitionCtor = window.SpeechRecognition || window.webkitSpeechRecognition || null;

    const SERVICE_MAP = {
      netflix: { label: "Netflix" },
      amazon: { label: "Amazon" },
      joyn: { label: "Joyn" },
      spotify: { label: "Spotify" }
    };

    const VOICE_SERVICE_ALIASES = {
      netflix: ["netflix", "net flix"],
      amazon: ["amazon", "prime", "prime video", "primevideo", "prime tv", "prime-tv"],
      joyn: ["joyn", "join", "joinn", "joint"],
      spotify: ["spotify", "spoti", "spoti fy", "musik"]
    };

    const VOICE_LEARN_STORAGE_KEY = "homepod.voice.learning.v1";
    const VOICE_LEARN_MIN_SCORE = 0.74;
    const VOICE_COMMAND_KEYWORDS = [
      "starte",
      "starten",
      "oeffne",
      "oeffnen",
      "offne",
      "offnen",
      "wechsel",
      "zu",
      "auf",
      "gehe",
      "spiel",
      "spiele",
      "spielt",
      "mach",
      "mache",
      "lautstaerke",
      "lautstarke",
      "volume",
      "lauter",
      "leiser",
      "zurueck",
      "zuruck",
      "menue",
      "menu",
      "verlassen",
      "kontrollzentrum",
      "control",
      "center",
      "airplay",
      "top",
      "status",
      "bildschirm",
      "screen",
      "start",
      "stop",
      "spiegeln",
      "system",
      "mirror",
      "pause",
      "play",
      "scan",
      "musik",
      "bitte",
      "voice",
      "reset",
      "sprache",
      "lernen",
      "loeschen",
      "verbinde",
      "verbinden",
      "schaue",
      "schau",
      "sehen",
      "weiter",
      "fortsetzen",
      "naechster",
      "homepod",
      "appletv",
      "apple",
      "tv",
      "beide"
    ];

    const VOICE_FILLER_WORDS = new Set([
      "bitte",
      "mal",
      "einmal",
      "doch",
      "jetzt",
      "gerne",
      "irgendwie",
      "kannst",
      "koenntest",
      "kann",
      "du",
      "mir",
      "denn",
      "die",
      "das",
      "der",
      "ein",
      "eine",
      "den",
      "dem",
      "zum",
      "zur"
    ]);

    const VOICE_UNIT_NUMBERS = {
      zero: 0,
      eins: 1,
      ein: 1,
      eine: 1,
      einer: 1,
      zwei: 2,
      zwo: 2,
      drei: 3,
      vier: 4,
      fuenf: 5,
      sechs: 6,
      sieben: 7,
      acht: 8,
      neun: 9,
      zehn: 10,
      elf: 11,
      zwoelf: 12,
      dreizehn: 13,
      vierzehn: 14,
      fuenfzehn: 15,
      sechzehn: 16,
      siebzehn: 17,
      achtzehn: 18,
      neunzehn: 19
    };

    const VOICE_TENS_NUMBERS = {
      zwanzig: 20,
      dreissig: 30,
      vierzig: 40,
      fuenfzig: 50,
      sechzig: 60,
      siebzig: 70,
      achtzig: 80,
      neunzig: 90,
      hundert: 100
    };

    let voiceRecognition = null;
    let voiceEnabled = false;
    let remoteMode = "appletv";
    let voiceKnownWords = null;
    let voiceLearning = loadVoiceLearning();

    function setStatus(message, isError = false) {
      statusEl.innerHTML = isError
        ? `<span class="bad">Fehler:</span> ${message}`
        : `<span class="ok">OK:</span> ${message}`;
    }

    function setOutput(text) {
      const trimmed = (text || "").toString().trim();
      outputEl.textContent = trimmed || "(keine Ausgabe)";
    }

    function setVoiceStatus(message, active = false) {
      if (!voiceStatusEl) {
        return;
      }
      voiceStatusEl.textContent = message;
      voiceStatusEl.classList.toggle("voice-live", active);
      voiceStatusEl.classList.toggle("voice-idle", !active);
      if (voiceToggleBtn) {
        voiceToggleBtn.classList.toggle("mic-active", active);
        voiceToggleBtn.textContent = active ? "Voice Stop" : "Voice Start";
      }
    }

    function describeVoiceIntent(intent) {
      if (!intent || !intent.type) {
        return "unknown";
      }
      if (intent.type === "open_service") {
        return `open_service(${intent.key})`;
      }
      if (intent.type === "set_volume") {
        return `set_volume(${intent.level})`;
      }
      if (intent.type === "step_volume") {
        return `step_volume(${intent.delta})`;
      }
      if (intent.type === "remote") {
        const suffix = intent.target ? `,${intent.target}` : "";
        return `remote(${intent.action}${suffix})`;
      }
      if (intent.type === "connect") {
        return `connect(${intent.target || "all"})`;
      }
      return intent.type;
    }

    function setVoiceIntentDebug(candidate, segments, intents, recognized = null) {
      if (!voiceIntentDebugEl) {
        return;
      }
      const segmentList = (segments || []).length ? segments.join(" | ") : "-";
      const intentList = (intents || []).length
        ? intents.map((intent) => describeVoiceIntent(intent)).join(" | ")
        : "-";
      const resultText = recognized === null ? "-"
        : (recognized ? "recognized" : "unrecognized");
      const lines = [
        `Voice Diagnose`,
        `Adapted: ${candidate?.adapted || "-"}`,
        `Segmente: ${segmentList}`,
        `Intents: ${intentList}`,
        `Result: ${resultText}`
      ];
      voiceIntentDebugEl.textContent = lines.join("\n");
    }

    function setRemoteMode(mode) {
      remoteMode = mode === "homepod" ? "homepod" : "appletv";

      document.querySelectorAll(".tv-only").forEach((el) => {
        el.classList.toggle("hidden", remoteMode !== "appletv");
      });

      if (deviceAppleTVBtn) {
        deviceAppleTVBtn.classList.toggle("is-active", remoteMode === "appletv");
      }
      if (deviceHomePodBtn) {
        deviceHomePodBtn.classList.toggle("is-active", remoteMode === "homepod");
      }
    }

    function setConnectStatus(message, isError = false) {
      if (!connectStatusEl) {
        return;
      }
      if (isError) {
        connectStatusEl.innerHTML = `<span class="bad">${message}</span>`;
        return;
      }
      connectStatusEl.innerHTML = `<span class="ok">${message}</span>`;
    }

    function setMediaHint(message) {
      if (!mediaHintEl) {
        return;
      }
      mediaHintEl.textContent = message;
    }

    function setScreenStatus(message, isError = false) {
      if (!screenStatusEl) {
        return;
      }
      const safe = escapeHtml(message);
      screenStatusEl.innerHTML = isError ? `<span class="bad">${safe}</span>` : safe;
    }

    function normalizeVoiceText(value) {
      return String(value || "")
        .toLowerCase()
        .replace(/ä/g, "ae")
        .replace(/ö/g, "oe")
        .replace(/ü/g, "ue")
        .replace(/ß/g, "ss")
        .replace(/[^a-z0-9 ]+/g, " ")
        .replace(/\s+/g, " ")
        .trim();
    }

    function createEmptyVoiceLearning() {
      return {
        phraseMap: {},
        tokenMap: {},
        learnedAt: 0
      };
    }

    function loadVoiceLearning() {
      try {
        const raw = localStorage.getItem(VOICE_LEARN_STORAGE_KEY);
        if (!raw) {
          return createEmptyVoiceLearning();
        }
        const parsed = JSON.parse(raw);
        if (!parsed || typeof parsed !== "object") {
          return createEmptyVoiceLearning();
        }
        return {
          phraseMap: parsed.phraseMap && typeof parsed.phraseMap === "object" ? parsed.phraseMap : {},
          tokenMap: parsed.tokenMap && typeof parsed.tokenMap === "object" ? parsed.tokenMap : {},
          learnedAt: Number(parsed.learnedAt || 0)
        };
      } catch (_error) {
        return createEmptyVoiceLearning();
      }
    }

    function saveVoiceLearning() {
      try {
        voiceLearning.learnedAt = Date.now();
        localStorage.setItem(VOICE_LEARN_STORAGE_KEY, JSON.stringify(voiceLearning));
      } catch (_error) {
        // Ignore storage failures (private mode, quota, etc.).
      }
    }

    function resetVoiceLearning() {
      voiceLearning = createEmptyVoiceLearning();
      saveVoiceLearning();
    }

    function buildVoiceKnownWords() {
      const words = new Set(VOICE_COMMAND_KEYWORDS);
      for (const aliases of Object.values(VOICE_SERVICE_ALIASES)) {
        for (const alias of aliases) {
          const normalized = normalizeVoiceText(alias);
          if (!normalized) {
            continue;
          }
          normalized.split(" ").forEach((token) => words.add(token));
        }
      }
      return Array.from(words).filter((token) => token && !/^\d+$/.test(token));
    }

    function getVoiceKnownWords() {
      if (!voiceKnownWords) {
        voiceKnownWords = buildVoiceKnownWords();
      }
      return voiceKnownWords;
    }

    function levenshteinDistance(a, b) {
      if (a === b) {
        return 0;
      }
      if (!a) {
        return b.length;
      }
      if (!b) {
        return a.length;
      }
      const prev = new Array(b.length + 1).fill(0);
      const curr = new Array(b.length + 1).fill(0);
      for (let j = 0; j <= b.length; j += 1) {
        prev[j] = j;
      }
      for (let i = 1; i <= a.length; i += 1) {
        curr[0] = i;
        for (let j = 1; j <= b.length; j += 1) {
          const cost = a[i - 1] === b[j - 1] ? 0 : 1;
          curr[j] = Math.min(
            prev[j] + 1,
            curr[j - 1] + 1,
            prev[j - 1] + cost
          );
        }
        for (let j = 0; j <= b.length; j += 1) {
          prev[j] = curr[j];
        }
      }
      return prev[b.length];
    }

    function similarityScore(a, b) {
      const maxLen = Math.max(a.length, b.length);
      if (!maxLen) {
        return 1;
      }
      return 1 - (levenshteinDistance(a, b) / maxLen);
    }

    function findClosestVoiceWord(token) {
      if (!token || token.length < 4 || /^\d+$/.test(token)) {
        return null;
      }
      let bestWord = "";
      let bestScore = 0;
      for (const knownWord of getVoiceKnownWords()) {
        if (!knownWord || Math.abs(knownWord.length - token.length) > 2) {
          continue;
        }
        const score = similarityScore(token, knownWord);
        if (score > bestScore) {
          bestScore = score;
          bestWord = knownWord;
        }
      }
      if (!bestWord || bestScore < VOICE_LEARN_MIN_SCORE) {
        return null;
      }
      return { token, canonical: bestWord, score: bestScore };
    }

    function resolveVoiceCommandCandidate(rawSpoken) {
      const normalized = normalizeVoiceText(rawSpoken);
      if (!normalized) {
        return {
          normalized: "",
          adapted: "",
          candidateTokenPairs: [],
          usedPhraseMap: false
        };
      }

      let adapted = normalized;
      let usedPhraseMap = false;
      const mappedPhrase = voiceLearning.phraseMap[adapted];
      if (mappedPhrase) {
        adapted = mappedPhrase;
        usedPhraseMap = true;
      }

      const candidateTokenPairs = [];
      const adaptedTokens = adapted.split(" ").map((token) => {
        if (!token) {
          return token;
        }
        const mappedToken = voiceLearning.tokenMap[token];
        if (mappedToken) {
          return mappedToken;
        }
        const closest = findClosestVoiceWord(token);
        if (!closest || closest.canonical === token) {
          return token;
        }
        candidateTokenPairs.push({
          from: token,
          to: closest.canonical
        });
        return closest.canonical;
      });

      return {
        normalized,
        adapted: adaptedTokens.join(" ").replace(/\s+/g, " ").trim(),
        candidateTokenPairs,
        usedPhraseMap
      };
    }

    function shouldLearnVoicePhrase(normalizedRaw, normalizedCanonical) {
      if (!normalizedRaw || !normalizedCanonical) {
        return false;
      }
      if (normalizedRaw === normalizedCanonical) {
        return false;
      }
      if (/\d/.test(normalizedRaw) || /\d/.test(normalizedCanonical)) {
        return false;
      }
      return normalizedRaw.split(" ").length <= 6;
    }

    function rememberVoiceLearning(candidate, canonicalCommand, allowPhraseLearning = true) {
      if (!candidate || !canonicalCommand) {
        return false;
      }
      let changed = false;
      for (const pair of candidate.candidateTokenPairs || []) {
        if (!pair || !pair.from || !pair.to || pair.from === pair.to) {
          continue;
        }
        if (voiceLearning.tokenMap[pair.from] === pair.to) {
          continue;
        }
        voiceLearning.tokenMap[pair.from] = pair.to;
        changed = true;
      }

      const normalizedCanonical = normalizeVoiceText(canonicalCommand);
      if (allowPhraseLearning && shouldLearnVoicePhrase(candidate.normalized, normalizedCanonical)) {
        if (voiceLearning.phraseMap[candidate.normalized] !== normalizedCanonical) {
          voiceLearning.phraseMap[candidate.normalized] = normalizedCanonical;
          changed = true;
        }
      }

      if (changed) {
        saveVoiceLearning();
      }
      return changed;
    }

    function escapeRegExp(value) {
      return String(value).replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }

    function detectVoiceServiceLaunch(command) {
      if (!command) {
        return null;
      }
      const hasLaunchIntent = /\b(start(?:e|en)?|oeffn(?:e|en)?|offn(?:e|en)?|wechsel(?:\s+(?:zu|auf))?|geh(?:e)?\s+zu|spiel(?:e|en)?|mach(?:\s+\w+){0,2}\s+auf|schau(?:e)?|sehen|nutz(?:e)?)\b/.test(command);
      const hasControlIntent = /\b(pause|stop|status|scan|zurueck|zuruck|lauter|leiser|lautstaerke|lautstarke|volume|kontrollzentrum|airplay)\b/.test(command);
      const mentionedService = detectVoiceServiceMention(command);
      if (!mentionedService) {
        return null;
      }
      if (hasLaunchIntent) {
        return mentionedService;
      }
      if (hasControlIntent) {
        return null;
      }
      const onlyFewWords = command.split(" ").length <= 3;
      return onlyFewWords ? mentionedService : null;
    }

    function detectVoiceServiceMention(command) {
      if (!command) {
        return null;
      }
      for (const [serviceKey, aliases] of Object.entries(VOICE_SERVICE_ALIASES)) {
        for (const alias of aliases) {
          const aliasRegex = new RegExp(`\\b${escapeRegExp(alias)}\\b`);
          if (aliasRegex.test(command)) {
            return serviceKey;
          }
        }
      }
      return null;
    }

    function hasWord(text, phrase) {
      if (!text || !phrase) {
        return false;
      }
      return new RegExp(`\\b${escapeRegExp(phrase)}\\b`).test(text);
    }

    function containsAnyWord(text, phrases) {
      for (const phrase of phrases) {
        if (hasWord(text, phrase)) {
          return true;
        }
      }
      return false;
    }

    function stripVoiceFillers(segment) {
      const tokens = String(segment || "")
        .split(" ")
        .map((token) => token.trim())
        .filter(Boolean)
        .filter((token) => !VOICE_FILLER_WORDS.has(token));
      return tokens.join(" ").trim();
    }

    function splitVoiceCommandSegments(command) {
      if (!command) {
        return [];
      }
      const separated = String(command)
        .replace(/[.,;:!?]+/g, " | ")
        .replace(/\b(?:und dann|und danach|dann|danach|anschliessend|anschliesend|sowie)\b/g, " | ");

      const commandStartWords = new Set([
        "starte",
        "starten",
        "oeffne",
        "oeffnen",
        "offne",
        "offnen",
        "wechsel",
        "spiel",
        "spiele",
        "play",
        "pause",
        "stop",
        "status",
        "scan",
        "verbinde",
        "verbinden",
        "lauter",
        "leiser",
        "lautstaerke",
        "lautstarke",
        "volume",
        "zurueck",
        "zuruck",
        "kontrollzentrum",
        "airplay",
        "bildschirm",
        "screen"
      ]);

      const finalParts = [];
      const rawParts = separated
        .split("|")
        .map((part) => normalizeVoiceText(part))
        .filter(Boolean);

      for (const rawPart of rawParts) {
        const tokens = rawPart.split(" ").filter(Boolean);
        if (!tokens.length) {
          continue;
        }
        let current = [];
        for (let i = 0; i < tokens.length; i += 1) {
          const token = tokens[i];
          const next = tokens[i + 1] || "";
          const prev = tokens[i - 1] || "";
          if (token === "und") {
            const prevNumber = parseSimpleGermanNumberToken(prev);
            const nextNumber = parseSimpleGermanNumberToken(next);
            if (prevNumber !== null && nextNumber !== null) {
              current.push(token);
              continue;
            }
            if (commandStartWords.has(next) && current.length) {
              finalParts.push(current.join(" "));
              current = [];
              continue;
            }
          }
          current.push(token);
        }
        if (current.length) {
          finalParts.push(current.join(" "));
        }
      }

      return finalParts
        .map((part) => stripVoiceFillers(part))
        .filter(Boolean);
    }

    function parseSimpleGermanNumberToken(token) {
      if (!token) {
        return null;
      }
      if (Object.prototype.hasOwnProperty.call(VOICE_UNIT_NUMBERS, token)) {
        return VOICE_UNIT_NUMBERS[token];
      }
      if (Object.prototype.hasOwnProperty.call(VOICE_TENS_NUMBERS, token)) {
        return VOICE_TENS_NUMBERS[token];
      }
      const directCompound = token.match(/^(ein|eins|zwei|zwo|drei|vier|fuenf|sechs|sieben|acht|neun)und(zwanzig|dreissig|vierzig|fuenfzig|sechzig|siebzig|achtzig|neunzig)$/);
      if (directCompound) {
        const unit = VOICE_UNIT_NUMBERS[directCompound[1]] || 0;
        const tens = VOICE_TENS_NUMBERS[directCompound[2]] || 0;
        return unit + tens;
      }
      return null;
    }

    function extractVoiceNumber(text) {
      if (!text) {
        return null;
      }
      const digitMatch = text.match(/\b(\d{1,3})\b/);
      if (digitMatch) {
        return Number(digitMatch[1]);
      }
      const tokens = text.split(" ").filter(Boolean);
      for (let i = 0; i < tokens.length; i += 1) {
        const single = parseSimpleGermanNumberToken(tokens[i]);
        if (single !== null) {
          return single;
        }
        if (i + 2 < tokens.length && tokens[i + 1] === "und") {
          const left = parseSimpleGermanNumberToken(tokens[i]);
          const right = parseSimpleGermanNumberToken(tokens[i + 2]);
          if (left !== null && right !== null && right >= 20) {
            return left + right;
          }
        }
      }
      return null;
    }

    function parseVolumeIntent(segment) {
      if (!segment) {
        return null;
      }
      const hasVolumeWord = containsAnyWord(segment, ["lautstaerke", "lautstarke", "volume"]);
      const hasLouderWord = containsAnyWord(segment, ["lauter", "hoeher"]);
      const hasLowerWord = containsAnyWord(segment, ["leiser", "leise", "weniger"]);

      if (hasVolumeWord) {
        const level = extractVoiceNumber(segment);
        if (level !== null) {
          return { type: "set_volume", level: Math.max(0, Math.min(100, level)) };
        }
      }
      if (hasLouderWord || hasLowerWord) {
        const amount = extractVoiceNumber(segment);
        const step = amount === null ? 5 : Math.max(1, Math.min(40, amount));
        return { type: "step_volume", delta: hasLowerWord ? -step : step };
      }
      return null;
    }

    function parseConnectIntent(segment) {
      if (!containsAnyWord(segment, ["verbinde", "verbinden", "connect"])) {
        return null;
      }
      if (containsAnyWord(segment, ["alle", "alles", "beide", "all"])) {
        return { type: "connect", target: "all" };
      }
      if (containsAnyWord(segment, ["homepod"])) {
        return { type: "connect", target: "homepod" };
      }
      if (containsAnyWord(segment, ["appletv", "apple tv"])) {
        return { type: "connect", target: "appletv" };
      }
      return { type: "connect", target: "all" };
    }

    function parseRemoteIntent(segment) {
      if (containsAnyWord(segment, ["zurueck", "zuruck", "menue verlassen", "menu verlassen"])) {
        return { type: "remote", action: "back", target: "appletv" };
      }
      if (containsAnyWord(segment, ["kontrollzentrum", "control center", "airplay"])) {
        return { type: "remote", action: "control_center", target: "appletv" };
      }
      if (hasWord(segment, "top menu")) {
        return { type: "remote", action: "top_menu", target: "appletv" };
      }
      if (containsAnyWord(segment, ["hoch", "oben"]) && !hasWord(segment, "lauter")) {
        return { type: "remote", action: "up", target: "appletv" };
      }
      if (containsAnyWord(segment, ["runter", "unten"]) && !containsAnyWord(segment, ["lauter", "leiser", "lautstaerke", "lautstarke", "volume"])) {
        return { type: "remote", action: "down", target: "appletv" };
      }
      if (containsAnyWord(segment, ["links"])) {
        return { type: "remote", action: "left", target: "appletv" };
      }
      if (containsAnyWord(segment, ["rechts"])) {
        return { type: "remote", action: "right", target: "appletv" };
      }
      if (containsAnyWord(segment, ["ok", "auswaehlen", "auswahlen", "bestaetigen"])) {
        return { type: "remote", action: "select", target: "appletv" };
      }
      return null;
    }

    function parseVoiceIntentSegment(segment) {
      const clean = stripVoiceFillers(segment);
      if (!clean) {
        return null;
      }

      if (containsAnyWord(clean, ["voice reset", "sprache reset", "sprache lernen loeschen"])) {
        return { type: "voice_reset" };
      }

      const volumeIntent = parseVolumeIntent(clean);
      if (volumeIntent) {
        return volumeIntent;
      }

      if (containsAnyWord(clean, ["bildschirm spiegeln", "system mirror"])) {
        return { type: "screen_mirror" };
      }
      if (containsAnyWord(clean, ["bildschirm start", "screen start"])) {
        return { type: "screen_start" };
      }
      if (containsAnyWord(clean, ["bildschirm stop", "screen stop"])) {
        return { type: "screen_stop" };
      }

      const connectIntent = parseConnectIntent(clean);
      if (connectIntent) {
        return connectIntent;
      }

      const serviceToLaunch = detectVoiceServiceLaunch(clean);
      if (serviceToLaunch) {
        return { type: "open_service", key: serviceToLaunch };
      }

      const remoteIntent = parseRemoteIntent(clean);
      if (remoteIntent) {
        return remoteIntent;
      }

      if (containsAnyWord(clean, ["status", "wie ist", "was laeuft", "was lauft"])) {
        return { type: "status" };
      }
      if (containsAnyWord(clean, ["scan", "suche geraete", "geraete suchen"])) {
        return { type: "scan" };
      }
      if (containsAnyWord(clean, ["pause", "pausieren"])) {
        return { type: "remote", action: "pause", target: "appletv" };
      }
      if (containsAnyWord(clean, ["play", "weiter", "fortsetzen", "abspielen"])) {
        return { type: "remote", action: "play", target: "appletv" };
      }
      if (containsAnyWord(clean, ["stop", "anhalten", "beenden"])) {
        return { type: "stop" };
      }
      return null;
    }

    function analyzeVoiceUtterance(command) {
      const segments = splitVoiceCommandSegments(command);
      if (!segments.length) {
        return { segments: [], intents: [] };
      }
      const intents = [];
      for (const segment of segments) {
        const intent = parseVoiceIntentSegment(segment);
        if (intent) {
          intents.push(intent);
        }
      }
      if (!intents.length) {
        const fallbackIntent = parseVoiceIntentSegment(command);
        if (fallbackIntent) {
          intents.push(fallbackIntent);
        }
      }
      return { segments, intents };
    }

    function parseVoiceUtterance(command) {
      return analyzeVoiceUtterance(command).intents;
    }

    function escapeHtml(value) {
      return String(value)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#39;");
    }

    function shortNameFromPath(path) {
      if (!path) {
        return "-";
      }
      const normalized = String(path).replace(/\\/g, "/");
      const parts = normalized.split("/");
      return parts[parts.length - 1] || normalized;
    }

    function formatBytes(bytesRaw) {
      const bytes = Number(bytesRaw || 0);
      if (!Number.isFinite(bytes) || bytes <= 0) {
        return "0 B";
      }
      const units = ["B", "KB", "MB", "GB"];
      let idx = 0;
      let value = bytes;
      while (value >= 1024 && idx < units.length - 1) {
        value /= 1024;
        idx += 1;
      }
      const decimals = idx === 0 ? 0 : 1;
      return `${value.toFixed(decimals)} ${units[idx]}`;
    }

    function formatUploadTime(tsRaw) {
      const ts = Number(tsRaw || 0);
      if (!Number.isFinite(ts) || ts <= 0) {
        return "-";
      }
      const d = new Date(ts * 1000);
      return d.toLocaleString("de-DE", { hour12: false });
    }

    async function api(path, options = {}) {
      const response = await fetch(path, {
        headers: { "Content-Type": "application/json" },
        ...options
      });
      const data = await response.json().catch(() => ({}));
      if (!response.ok || data.ok === false) {
        throw new Error(data.error || `${response.status} ${response.statusText}`);
      }
      return data;
    }

    async function loadConfig() {
      const data = await api("/api/config");
      $("ip").value = data.ip || "";
      $("name").value = data.name || "";
      if (headNodeEl) {
        headNodeEl.textContent = `Node: ${data.name || "-"}`;
      }
      if (overviewNodeEl) {
        overviewNodeEl.textContent = data.name || "-";
      }
      if (overviewIpEl) {
        overviewIpEl.textContent = data.ip || "-";
      }
      setStatus(`Geraet geladen: ${data.name} (${data.ip})`);
    }

    async function saveConfig() {
      const body = {
        ip: $("ip").value.trim(),
        name: $("name").value.trim()
      };
      const data = await api("/api/config", {
        method: "POST",
        body: JSON.stringify(body)
      });
      setStatus(`Geraet gespeichert: ${data.name} (${data.ip})`);
    }

    async function loadTVConfig() {
      const data = await api("/api/tv_config");
      $("tvIp").value = data.ip || "";
      $("tvName").value = data.name || "";
      setStatus(`Apple TV geladen: ${data.name} (${data.ip})`);
    }

    async function saveTVConfig() {
      const body = {
        ip: $("tvIp").value.trim(),
        name: $("tvName").value.trim()
      };
      const data = await api("/api/tv_config", {
        method: "POST",
        body: JSON.stringify(body)
      });
      setStatus(`Apple TV gespeichert: ${data.name} (${data.ip})`);
    }

    function formatConnectionLine(entry) {
      const prefix = entry.connected ? "OK" : "FAIL";
      const detail = entry.connected ? "verbunden" : (entry.stderr || "nicht verbunden");
      return `${prefix} ${entry.target} (${entry.name} ${entry.ip}) - ${detail}`;
    }

    async function connectTarget(target = "all") {
      const data = await api("/api/connect", {
        method: "POST",
        body: JSON.stringify({ target })
      });

      const lines = [];
      if (data.homepod) {
        lines.push(formatConnectionLine(data.homepod));
      }
      if (data.appletv) {
        lines.push(formatConnectionLine(data.appletv));
      }
      if (lines.length === 0) {
        setConnectStatus("Keine Verbindungsdaten vorhanden", true);
        setOutput("Connect: keine Daten");
        setStatus("Verbindungspruefung ohne Ergebnis", true);
        return;
      }

      const summary = data.connected ? "Verbindung steht" : "Verbindung teilweise/fehlerhaft";
      setConnectStatus(summary, !data.connected);
      setOutput(lines.join("\n"));
      setStatus(`Connect (${target}): ${summary}`, !data.connected);
    }

    function renderQueue(snapshot) {
      const items = Array.isArray(snapshot.items) ? snapshot.items : [];
      const current = snapshot.current || null;
      const enabled = Boolean(snapshot.enabled);
      const count = Number.isFinite(snapshot.count) ? snapshot.count : items.length;

      if (queueBadgeEl) {
        const currentName = current ? shortNameFromPath(current) : "-";
        queueBadgeEl.textContent = `Queue: ${count} | Aktuell: ${currentName} | Mode: ${enabled ? "an" : "aus"}`;
      }

      if (!queueListEl) {
        return;
      }

      const rows = [];
      if (current) {
        rows.push(`
          <div class="list-item">
            <span class="list-name">Aktuell: ${escapeHtml(shortNameFromPath(current))}</span>
            <span class="list-meta">${escapeHtml(current)}</span>
            <div class="list-actions">
              <button class="mini-btn btn-secondary" data-action="use-path" data-path="${encodeURIComponent(current)}">In Feld</button>
            </div>
          </div>
        `);
      }

      items.forEach((path, idx) => {
        rows.push(`
          <div class="list-item">
            <span class="list-name">${idx + 1}. ${escapeHtml(shortNameFromPath(path))}</span>
            <span class="list-meta">${escapeHtml(path)}</span>
            <div class="list-actions">
              <button class="mini-btn btn-secondary" data-action="use-path" data-path="${encodeURIComponent(path)}">In Feld</button>
              <button class="mini-btn btn-primary" data-action="play-path" data-path="${encodeURIComponent(path)}">Direkt Play</button>
            </div>
          </div>
        `);
      });

      if (rows.length === 0) {
        queueListEl.innerHTML = `<div class="list-item"><span class="list-meta">Queue leer</span></div>`;
        return;
      }
      queueListEl.innerHTML = rows.join("");
    }

    async function refreshQueue() {
      const data = await api("/api/queue");
      renderQueue(data);
      return data;
    }

    async function queueAddPath(path) {
      const targetPath = String(path || "").trim();
      if (!targetPath) {
        throw new Error("Pfad fuer Queue fehlt");
      }
      const data = await api("/api/queue/add", {
        method: "POST",
        body: JSON.stringify({ path: targetPath })
      });
      renderQueue(data);
      setStatus("Zur Playlist hinzugefuegt");
    }

    async function queueAddFromInput() {
      const path = $("path").value.trim();
      if (!path) {
        throw new Error("Pfad fehlt");
      }
      await queueAddPath(path);
    }

    async function queueStart() {
      const data = await api("/api/queue/start", { method: "POST", body: "{}" });
      renderQueue(data);
      await refreshStreamStatus();
      setStatus("Playlist gestartet");
    }

    async function queueNext() {
      const data = await api("/api/queue/next", { method: "POST", body: "{}" });
      renderQueue(data);
      await refreshStreamStatus();
      setStatus("Naechster Queue-Titel");
    }

    async function queueClear() {
      const data = await api("/api/queue/clear", { method: "POST", body: "{}" });
      renderQueue(data);
      setStatus("Playlist geleert");
    }

    function applyPath(path) {
      const targetPath = String(path || "").trim();
      if (!targetPath) {
        return;
      }
      $("path").value = targetPath;
      setMediaHint(`Auswahl: ${shortNameFromPath(targetPath)}`);
    }

    function renderHistory(items) {
      if (!historyListEl) {
        return;
      }
      if (!Array.isArray(items) || items.length === 0) {
        historyListEl.innerHTML = `<div class="list-item"><span class="list-meta">Noch keine Uploads</span></div>`;
        return;
      }
      const rows = items.slice(0, 18).map((item) => {
        const path = String(item.path || "");
        const encoded = encodeURIComponent(path);
        const filename = shortNameFromPath(item.filename || path);
        const meta = `${item.media_type || "media"} | ${formatBytes(item.size)} | ${formatUploadTime(item.uploaded_at)}`;
        return `
          <div class="list-item">
            <span class="list-name">${escapeHtml(filename)}</span>
            <span class="list-meta">${escapeHtml(meta)}</span>
            <div class="list-actions">
              <button class="mini-btn btn-secondary" data-action="use-path" data-path="${encoded}">In Feld</button>
              <button class="mini-btn btn-tertiary" data-action="queue-add" data-path="${encoded}">+ Queue</button>
              <button class="mini-btn btn-primary" data-action="play-path" data-path="${encoded}">Play</button>
            </div>
          </div>
        `;
      });
      historyListEl.innerHTML = rows.join("");
    }

    async function refreshHistory() {
      const data = await api("/api/upload_history");
      renderHistory(data.items || []);
    }

    async function refreshVolume() {
      const data = await api("/api/volume");
      if (typeof data.level === "number") {
        const rounded = Math.round(data.level * 10) / 10;
        $("volumeLabel").textContent = rounded.toString();
        $("volumeSlider").value = Math.round(rounded).toString();
        if (overviewVolumeEl) {
          overviewVolumeEl.textContent = `${rounded}%`;
        }
      }
      setStatus("Lautstaerke aktualisiert");
    }

    async function setVolume(level) {
      const target = typeof level === "number"
        ? level
        : Number($("volumeSlider").value);

      await api("/api/volume", {
        method: "POST",
        body: JSON.stringify({ level: target })
      });
      await refreshVolume();
      setStatus(`Lautstaerke auf ${target}% gesetzt`);
    }

    async function play() {
      const path = $("path").value.trim();
      if (!path) {
        throw new Error("Pfad fehlt");
      }
      await api("/api/play", {
        method: "POST",
        body: JSON.stringify({ path })
      });
      setStatus("Stream gestartet");
      await refreshStreamStatus();
      await refreshQueue();
    }

    async function uploadMediaFile(file) {
      if (!file) {
        throw new Error("keine Datei ausgewaehlt");
      }

      setStatus(`Upload startet: ${file.name}`);
      setMediaHint(`Upload laeuft: ${file.name}`);

      const response = await fetch("/api/upload_media", {
        method: "POST",
        headers: {
          "Content-Type": "application/octet-stream",
          "X-Filename": encodeURIComponent(file.name),
        },
        body: file,
      });
      const data = await response.json().catch(() => ({}));
      if (!response.ok || data.ok === false) {
        throw new Error(data.error || `${response.status} ${response.statusText}`);
      }

      $("path").value = data.path;
      const mb = (Number(data.size || 0) / (1024 * 1024)).toFixed(2);
      setMediaHint(`${data.filename} (${mb} MB)`);
      setOutput(`Upload ok\n${data.path}\n${data.size} bytes`);
      setStatus(`Medien hinzugefuegt: ${data.filename}`);
      await refreshHistory();
    }

    function chooseMediaFile() {
      if (!mediaFileInputEl) {
        throw new Error("Dateiauswahl nicht verfuegbar");
      }
      mediaFileInputEl.click();
    }

    async function stop() {
      await api("/api/stop", { method: "POST", body: "{}" });
      setStatus("Stop gesendet");
      await refreshStreamStatus();
      await refreshQueue();
    }

    async function refreshPlaying() {
      const data = await api("/api/playing");
      const parsed = data.parsed || {};
      const media = parsed["Media type"] || "Unknown";
      const state = parsed["Device state"] || "Unknown";
      const pos = parsed["Position"] || "-";
      if (overviewStateEl) {
        overviewStateEl.textContent = state;
      }
      setOutput(data.raw || "");
      setStatus(`Media=${media}, State=${state}, Position=${pos}`);
    }

    async function refreshStreamStatus() {
      const data = await api("/api/stream_status");
      $("streamFlag").textContent = data.active ? "aktiv" : "inaktiv";
      $("streamFlag").className = data.active ? "ok" : "bad";
      if (overviewStreamEl) {
        overviewStreamEl.textContent = data.active ? "aktiv" : "inaktiv";
      }
    }

    async function refreshScreenStatus() {
      const data = await api("/api/screen_status");
      const active = Boolean(data.active);

      if (active) {
        setScreenStatus(`Aktiv: ${data.url || "-"}`);
      } else if (data.last_error) {
        setScreenStatus(`Inaktiv: ${data.last_error}`, true);
      } else {
        setScreenStatus("Screen-Stream: inaktiv");
      }
      return data;
    }

    async function startScreenStream() {
      const payload = {};
      const display = $("screenDisplay").value.trim();
      const size = $("screenSize").value.trim();
      const fps = $("screenFps").value.trim();
      if (display) {
        payload.display = display;
      }
      if (size) {
        payload.size = size;
      }
      if (fps) {
        payload.fps = fps;
      }
      let data;
      try {
        data = await api("/api/screen_start", {
          method: "POST",
          body: JSON.stringify(payload),
        });
      } catch (error) {
        const message = error?.message || String(error);
        const canFallback =
          message.includes("Apple TV hat den Bildschirmstream nicht uebernommen") ||
          message.includes("playback-info") ||
          message.includes("code 500");
        if (!canFallback) {
          throw error;
        }

        const mirror = await api("/api/open_system_mirror", { method: "POST", body: "{}" });
        setOutput(
          [
            "Apple-TV Direktstream fehlgeschlagen",
            message,
            "",
            "System-Mirroring als Fallback gestartet",
            `PID: ${mirror.pid || "-"}`,
            `Display: ${mirror.display || "-"}`,
            `Command: ${(mirror.command || []).join(" ")}`,
          ].join("\n")
        );
        setStatus(
          "Direktstream fehlgeschlagen, System-Mirroring als Fallback gestartet",
          true
        );
        await refreshScreenStatus();
        return;
      }

      const lines = [
        "Bildschirmstream gestartet",
        `URL: ${data.url || "-"}`,
        `Display: ${data.display || "-"}`,
        `Size/FPS: ${data.size || "-"} @ ${data.fps || "-"}`,
      ];
      if (data.launch_warning) {
        lines.push(`WARNUNG: ${data.launch_warning}`);
        const detail = data.launch_detail || data.launch_stderr;
        if (detail) {
          lines.push(`Detail: ${detail}`);
        }
      } else {
        if (data.launch_stdout) {
          lines.push(data.launch_stdout);
        }
        if (data.launch_stderr) {
          lines.push(data.launch_stderr);
        }
      }
      setOutput(lines.join("\n"));
      setStatus(
        data.launch_warning
          ? "Bildschirmstream gestartet (mit Apple-TV Warnung)"
          : "Bildschirmstream auf Apple TV gestartet"
      );
      await refreshScreenStatus();
    }

    async function stopScreenStream() {
      const data = await api("/api/screen_stop", { method: "POST", body: "{}" });
      const tvInfo = data.tv_returncode === 0
        ? "Apple TV stop gesendet"
        : (data.tv_stderr || data.tv_stdout || "Apple TV stop Rueckmeldung fehlt");
      setOutput(["Bildschirmstream gestoppt", tvInfo].join("\n"));
      setStatus("Bildschirmstream gestoppt");
      await refreshScreenStatus();
    }

    async function openSystemMirror() {
      const data = await api("/api/open_system_mirror", { method: "POST", body: "{}" });
      setOutput(
        [
          "System-Mirroring geoeffnet",
          `PID: ${data.pid || "-"}`,
          `Display: ${data.display || "-"}`,
          `Command: ${(data.command || []).join(" ")}`,
        ].join("\n")
      );
      setStatus("System-Mirroring gestartet");
    }

    async function stepVolume(delta) {
      const current = Number($("volumeSlider").value || "0");
      const next = Math.max(0, Math.min(100, current + delta));
      $("volumeSlider").value = next.toString();
      await setVolume(next);
    }

    async function remote(action, targetOverride = null) {
      const target = (targetOverride || remoteMode || "appletv").toLowerCase();
      const data = await api("/api/remote", {
        method: "POST",
        body: JSON.stringify({ action, target })
      });
      const text = [data.stdout || "", data.stderr || ""].filter(Boolean).join("\n");
      if (text) {
        setOutput(text);
      } else {
        setOutput(`Remote bestaetigt: ${action} (${data.target || target})`);
      }
      setStatus(`Remote action: ${action} (${data.target || target})`);
    }

    async function showFeatures() {
      const data = await api("/api/features");
      setOutput(data.raw || "");
      setStatus("Features geladen");
    }

    async function showDeviceInfo() {
      const data = await api("/api/device_info");
      setOutput(data.raw || "");
      setStatus("Device Info geladen");
    }

    async function scanDevices() {
      const data = await api("/api/scan");
      setOutput(data.raw || "");
      setStatus("Scan abgeschlossen");
    }

    async function runRawCommand() {
      const command = $("rawCommand").value.trim();
      if (!command) {
        throw new Error("command fehlt");
      }
      const data = await api("/api/command", {
        method: "POST",
        body: JSON.stringify({ command })
      });
      const text = [data.stdout || "", data.stderr || ""].filter(Boolean).join("\n");
      setOutput(text);
      setStatus(`Command ausgefuehrt: ${command}`);
    }

    async function openService(key) {
      const service = SERVICE_MAP[key];
      if (!service) {
        throw new Error("unbekannter Service");
      }
      const data = await api("/api/service_launch", {
        method: "POST",
        body: JSON.stringify({ service: key })
      });
      const text = [
        `${data.label} -> ${data.target_name} (${data.target_ip})`,
        `bundle: ${data.bundle_id}`,
        data.stdout || "",
        data.stderr || ""
      ].filter(Boolean).join("\n");
      setOutput(text);
      setStatus(`${data.label} wurde auf Apple TV gestartet`);
    }

    function canonicalFromVoiceIntent(intent) {
      if (!intent || !intent.type) {
        return "unknown";
      }
      if (intent.type === "set_volume") {
        return `lautstaerke ${intent.level}`;
      }
      if (intent.type === "step_volume") {
        return intent.delta >= 0 ? `lauter ${intent.delta}` : `leiser ${Math.abs(intent.delta)}`;
      }
      if (intent.type === "open_service") {
        return `oeffne ${intent.key}`;
      }
      if (intent.type === "remote") {
        return `remote ${intent.action}`;
      }
      if (intent.type === "status") {
        return "status";
      }
      if (intent.type === "screen_start") {
        return "bildschirm start";
      }
      if (intent.type === "screen_stop") {
        return "bildschirm stop";
      }
      if (intent.type === "screen_mirror") {
        return "bildschirm spiegeln";
      }
      if (intent.type === "scan") {
        return "scan";
      }
      if (intent.type === "stop") {
        return "stop";
      }
      if (intent.type === "connect") {
        return `verbinde ${intent.target || "all"}`;
      }
      if (intent.type === "voice_reset") {
        return "voice reset";
      }
      return intent.type;
    }

    async function executeVoiceIntent(intent) {
      if (!intent || !intent.type) {
        return false;
      }

      if (intent.type === "voice_reset") {
        resetVoiceLearning();
        setOutput("Voice Lernprofil geloescht");
        setStatus("Voice Lernprofil zurueckgesetzt");
        return true;
      }
      if (intent.type === "set_volume") {
        $("volumeSlider").value = String(intent.level);
        await setVolume(intent.level);
        return true;
      }
      if (intent.type === "step_volume") {
        await stepVolume(intent.delta);
        return true;
      }
      if (intent.type === "open_service") {
        await openService(intent.key);
        return true;
      }
      if (intent.type === "remote") {
        await remote(intent.action, intent.target || null);
        return true;
      }
      if (intent.type === "status") {
        await refreshPlaying();
        await refreshVolume();
        await refreshScreenStatus();
        return true;
      }
      if (intent.type === "screen_start") {
        await startScreenStream();
        return true;
      }
      if (intent.type === "screen_stop") {
        await stopScreenStream();
        return true;
      }
      if (intent.type === "screen_mirror") {
        await openSystemMirror();
        return true;
      }
      if (intent.type === "scan") {
        await scanDevices();
        return true;
      }
      if (intent.type === "stop") {
        await stop();
        return true;
      }
      if (intent.type === "connect") {
        await connectTarget(intent.target || "all");
        return true;
      }
      return false;
    }

    async function executeVoiceCommand(raw, options = {}) {
      const spoken = String(raw || "").trim();
      const silentUnknown = Boolean(options.silentUnknown);
      const candidate = resolveVoiceCommandCandidate(spoken);
      const command = candidate.adapted;
      if (!command) {
        return { recognized: false };
      }

      const showCommand = candidate.normalized !== command
        ? `${spoken} -> ${command}`
        : spoken;
      setVoiceStatus(`Erkannt: ${showCommand}`, true);

      const analysis = analyzeVoiceUtterance(command);
      const intents = analysis.intents;
      setVoiceIntentDebug(candidate, analysis.segments, intents, null);
      if (intents.length) {
        const canonicalCommands = [];
        for (const intent of intents) {
          const executed = await executeVoiceIntent(intent);
          if (executed) {
            canonicalCommands.push(canonicalFromVoiceIntent(intent));
          }
        }
        if (canonicalCommands.length) {
          const canonical = canonicalCommands.join(" | ");
          const allowPhraseLearning = canonicalCommands.length === 1;
          rememberVoiceLearning(candidate, canonical, allowPhraseLearning);
          setVoiceIntentDebug(candidate, analysis.segments, intents, true);
          return { recognized: true, canonicalCommand: canonical };
        }
      }

      if (!silentUnknown) {
        setVoiceIntentDebug(candidate, analysis.segments, intents, false);
        setOutput(
          `Voice unklar.\nOriginal: "${spoken}"\nNormalisiert: "${candidate.normalized}"\nLernmodul: "${command}"`
        );
        setStatus(`Voice unbekannt: ${spoken}`, true);
      }
      return {
        recognized: false,
        command,
        normalized: candidate.normalized
      };
    }

    async function processVoiceAlternatives(result) {
      if (!result || !result.length) {
        return;
      }
      const seen = new Set();
      const transcripts = [];
      for (let i = 0; i < result.length; i += 1) {
        const transcript = String(result[i]?.transcript || "").trim();
        if (!transcript) {
          continue;
        }
        const normalized = normalizeVoiceText(transcript);
        if (!normalized || seen.has(normalized)) {
          continue;
        }
        seen.add(normalized);
        transcripts.push(transcript);
      }
      if (!transcripts.length) {
        return;
      }

      for (let i = 0; i < transcripts.length; i += 1) {
        const outcome = await executeVoiceCommand(transcripts[i], {
          silentUnknown: i < transcripts.length - 1
        });
        if (outcome && outcome.recognized) {
          return;
        }
      }
    }

    function ensureVoiceRecognition() {
      if (voiceRecognition) {
        return true;
      }
      if (!SpeechRecognitionCtor) {
        setVoiceStatus("Sprachsteuerung: Browser unterstuetzt SpeechRecognition nicht", false);
        return false;
      }

      voiceRecognition = new SpeechRecognitionCtor();
      voiceRecognition.lang = "de-DE";
      voiceRecognition.interimResults = false;
      voiceRecognition.continuous = true;
      voiceRecognition.maxAlternatives = 5;

      voiceRecognition.onstart = () => {
        setVoiceStatus("Sprachsteuerung: aktiv", true);
      };

      voiceRecognition.onend = () => {
        if (voiceEnabled) {
          try {
            voiceRecognition.start();
          } catch (_error) {
            setVoiceStatus("Sprachsteuerung: Neustart fehlgeschlagen", false);
          }
          return;
        }
        setVoiceStatus("Sprachsteuerung: inaktiv", false);
      };

      voiceRecognition.onerror = (event) => {
        setVoiceStatus(`Sprachsteuerung Fehler: ${event.error}`, false);
      };

      voiceRecognition.onresult = (event) => {
        const index = event.resultIndex;
        const result = event.results[index];
        run(() => processVoiceAlternatives(result));
      };

      return true;
    }

    function toggleVoice() {
      if (!ensureVoiceRecognition()) {
        return;
      }

      voiceEnabled = !voiceEnabled;
      if (voiceEnabled) {
        try {
          voiceRecognition.start();
          setVoiceStatus("Sprachsteuerung: startet...", true);
        } catch (error) {
          voiceEnabled = false;
          setVoiceStatus(`Sprachsteuerung Fehler: ${error.message || String(error)}`, false);
        }
        return;
      }

      try {
        voiceRecognition.stop();
      } catch (_error) {
        setVoiceStatus("Sprachsteuerung: inaktiv", false);
      }
    }

    function showVoiceHelp() {
      setOutput(
        [
          "Voice Befehle:",
          "- Ganze Saetze: 'kannst du bitte netflix oeffnen'",
          "- Mehrfachaktionen: 'lauter und dann status'",
          "- starte joyn / oeffne netflix / wechsel zu spotify",
          "- play / pause / stop / weiter / fortsetzen",
          "- lauter / leiser / lauter um 10 / lautstaerke 35",
          "- status / scan / verbinde homepod / verbinde alle",
          "- zurueck / menue verlassen",
          "- kontrollzentrum / airplay",
          "- bildschirm start / bildschirm stop",
          "- Voice Diagnose zeigt Segmente + Intents live",
          "- lernfaehig fuer Aussprache-Varianten (lokal gespeichert)",
          "- voice reset / sprache reset (Lerndaten loeschen)"
        ].join("\n")
      );
      setStatus("Voice Hilfe angezeigt");
    }

    async function run(action) {
      try {
        await action();
      } catch (error) {
        setStatus(error.message || String(error), true);
      }
    }

    function isTypingTarget(target) {
      if (!target) {
        return false;
      }
      const tag = (target.tagName || "").toLowerCase();
      if (tag === "input" || tag === "textarea" || tag === "select") {
        return true;
      }
      return Boolean(target.isContentEditable);
    }

    $("saveConfig").addEventListener("click", () => run(saveConfig));
    $("reloadConfig").addEventListener("click", () => run(loadConfig));
    $("connectHomepod").addEventListener("click", () => run(() => connectTarget("homepod")));
    $("connectAppleTV").addEventListener("click", () => run(() => connectTarget("appletv")));
    $("connectAll").addEventListener("click", () => run(() => connectTarget("all")));
    $("addMedia").addEventListener("click", () => run(chooseMediaFile));
    $("queueAdd").addEventListener("click", () => run(queueAddFromInput));
    $("queueStart").addEventListener("click", () => run(queueStart));
    $("queueNext").addEventListener("click", () => run(queueNext));
    $("queueClear").addEventListener("click", () => run(queueClear));
    $("setVolume").addEventListener("click", () => run(() => setVolume()));
    $("volDown").addEventListener("click", () => run(() => stepVolume(-5)));
    $("volUp").addEventListener("click", () => run(() => stepVolume(5)));
    $("refreshVolume").addEventListener("click", () => run(refreshVolume));
    $("play").addEventListener("click", () => run(play));
    $("stop").addEventListener("click", () => run(stop));
    $("refreshPlaying").addEventListener("click", () => run(refreshPlaying));
    $("rPlayPause").addEventListener("click", () => run(() => remote("select")));
    $("rPlay").addEventListener("click", () => run(() => remote("play")));
    $("rPause").addEventListener("click", () => run(() => remote("pause")));
    $("rStop").addEventListener("click", () => run(() => remote("stop")));
    $("rPrev").addEventListener("click", () => run(() => remote("previous")));
    $("rNext").addEventListener("click", () => run(() => remote("next")));
    $("rSkipBack").addEventListener("click", () => run(() => remote("skip_backward")));
    $("rSkipFwd").addEventListener("click", () => run(() => remote("skip_forward")));
    $("rBackExit").addEventListener("click", () => run(() => remote("back")));
    $("rMenu").addEventListener("click", () => run(() => remote("menu")));
    $("rHome").addEventListener("click", () => run(() => remote("home")));
    $("rTopMenu").addEventListener("click", () => run(() => remote("top_menu")));
    $("rControlCenter").addEventListener("click", () => run(() => remote("control_center")));
    if ($("rUp")) {
      $("rUp").addEventListener("click", () => run(() => remote("up")));
    }
    if ($("rDown")) {
      $("rDown").addEventListener("click", () => run(() => remote("down")));
    }
    if ($("rLeft")) {
      $("rLeft").addEventListener("click", () => run(() => remote("left")));
    }
    if ($("rRight")) {
      $("rRight").addEventListener("click", () => run(() => remote("right")));
    }
    $("rVolUp").addEventListener("click", () => run(() => remote("volume_up")));
    $("rVolDown").addEventListener("click", () => run(() => remote("volume_down")));
    $("showFeatures").addEventListener("click", () => run(showFeatures));
    $("showDeviceInfo").addEventListener("click", () => run(showDeviceInfo));
    $("scanDevices").addEventListener("click", () => run(scanDevices));
    $("runRawCommand").addEventListener("click", () => run(runRawCommand));
    $("svcNetflix").addEventListener("click", () => run(() => openService("netflix")));
    $("svcAmazon").addEventListener("click", () => run(() => openService("amazon")));
    $("svcJoyn").addEventListener("click", () => run(() => openService("joyn")));
    $("svcSpotify").addEventListener("click", () => run(() => openService("spotify")));
    $("saveTvConfig").addEventListener("click", () => run(saveTVConfig));
    $("reloadTvConfig").addEventListener("click", () => run(loadTVConfig));
    $("screenStart").addEventListener("click", () => run(startScreenStream));
    $("screenStop").addEventListener("click", () => run(stopScreenStream));
    $("screenRefresh").addEventListener("click", () => run(refreshScreenStatus));
    $("systemMirrorOpen").addEventListener("click", () => run(openSystemMirror));
    $("voiceToggle").addEventListener("click", () => toggleVoice());
    $("voiceHelp").addEventListener("click", () => run(showVoiceHelp));
    document.addEventListener("keydown", (event) => {
      if (event.repeat || isTypingTarget(event.target)) {
        return;
      }

      let action = null;
      if (event.key === "ArrowUp") {
        action = "up";
      } else if (event.key === "ArrowDown") {
        action = "down";
      } else if (event.key === "ArrowLeft") {
        action = "left";
      } else if (event.key === "ArrowRight") {
        action = "right";
      } else if (event.key === "Enter") {
        action = "select";
      }

      if (!action) {
        return;
      }

      event.preventDefault();
      run(() => remote(action));
    });
    if (deviceAppleTVBtn) {
      deviceAppleTVBtn.addEventListener("click", () => setRemoteMode("appletv"));
    }
    if (deviceHomePodBtn) {
      deviceHomePodBtn.addEventListener("click", () => setRemoteMode("homepod"));
    }
    if (mediaFileInputEl) {
      mediaFileInputEl.addEventListener("change", () => {
        const file = mediaFileInputEl.files && mediaFileInputEl.files[0] ? mediaFileInputEl.files[0] : null;
        run(() => uploadMediaFile(file));
        mediaFileInputEl.value = "";
      });
    }
    if (historyListEl) {
      historyListEl.addEventListener("click", (event) => {
        const button = event.target.closest("button[data-action]");
        if (!button) {
          return;
        }
        const action = button.dataset.action || "";
        const encodedPath = button.dataset.path || "";
        const path = decodeURIComponent(encodedPath);
        if (action === "use-path") {
          applyPath(path);
          setStatus("Pfad aus Historie uebernommen");
          return;
        }
        if (action === "queue-add") {
          run(() => queueAddPath(path));
          return;
        }
        if (action === "play-path") {
          applyPath(path);
          run(play);
        }
      });
    }
    if (queueListEl) {
      queueListEl.addEventListener("click", (event) => {
        const button = event.target.closest("button[data-action]");
        if (!button) {
          return;
        }
        const action = button.dataset.action || "";
        const encodedPath = button.dataset.path || "";
        const path = decodeURIComponent(encodedPath);
        if (action === "use-path") {
          applyPath(path);
          setStatus("Pfad aus Playlist uebernommen");
          return;
        }
        if (action === "play-path") {
          applyPath(path);
          run(play);
        }
      });
    }

    (async () => {
      $("screenDisplay").value = ":0.0";
      $("screenSize").value = "1280x720";
      $("screenFps").value = "22";
      await run(loadConfig);
      await run(loadTVConfig);
      await run(() => connectTarget("all"));
      await run(refreshHistory);
      await run(refreshQueue);
      await run(refreshVolume);
      await run(refreshStreamStatus);
      await run(refreshScreenStatus);
      await run(refreshPlaying);
      setRemoteMode("appletv");
      setVoiceStatus("Sprachsteuerung: inaktiv", false);
      setOutput("Bereit fuer atvremote-Kommandos.");
      setInterval(() => run(refreshStreamStatus), 4000);
      setInterval(() => run(refreshScreenStatus), 6000);
      setInterval(() => run(refreshPlaying), 12000);
      setInterval(() => run(refreshQueue), 4500);
    })();
  </script>
</body>
</html>
